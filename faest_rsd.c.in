/*
 *  SPDX-License-Identifier: MIT
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "faest_aes.h"
#include "fields.h"
#include "vole.h"
#include "universal_hashing.h"
#include "utils.h"
#include "parameters.h"
#include "random_oracle.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

// clang-format off
#define RESOLVED_SSS_LAMBDA RESOLVED_@SSS@_LAMBDA

#define bfSSS_t bf@SSS@_t
#define bfSSS_load bf@SSS@_load
#define bfSSS_from_bit bf@SSS@_from_bit
#define bfSSS_store bf@SSS@_store
#define bfSSS_zero bf@SSS@_zero
#define bfSSS_one bf@SSS@_one
#define bfSSS_add bf@SSS@_add
#define bfSSS_mul bf@SSS@_mul
#define bfSSS_mul_bit bf@SSS@_mul_bit
#define bfSSS_byte_combine bf@SSS@_byte_combine
#define bfSSS_byte_combine_bits bf@SSS@_byte_combine_bits
#define bfSSS_sum_poly bf@SSS@_sum_poly
#define bfSSS_sum_poly_bits bf@SSS@_sum_poly_bits
#define BFSSS_NUM_BYTES BF@SSS@_NUM_BYTES
#define BFSSS_ALIGN BF@SSS@_ALIGN

#define zk_hash_SSS_ctx zk_hash_@SSS@_ctx
#define zk_hash_SSS_finalize zk_hash_@SSS@_finalize
#define zk_hash_SSS_init zk_hash_@SSS@_init
#define zk_hash_SSS_update zk_hash_@SSS@_update

#define zk_hash_SSS_3_ctx zk_hash_@SSS@_3_ctx
#define zk_hash_SSS_3_finalize zk_hash_@SSS@_3_finalize
#define zk_hash_SSS_3_init zk_hash_@SSS@_3_init
#define zk_hash_SSS_3_update zk_hash_@SSS@_3_update

// clang-format on

/* pad sizes to multiples of some value; assumes that a is a power of 2 */
#define PAD_TO(s, a) (((s) + (a) - 1) & ~((a) - 1))
#define BFSSS_ALLOC(s) faest_aligned_alloc(BFSSS_ALIGN, PAD_TO((s) * sizeof(bfSSS_t), BFSSS_ALIGN))

#define RCON_EVERY (4 * (RESOLVED_SSS_LAMBDA / 128))

// COLOUM TO ROW MAJOR
static bfSSS_t* rsd_column_to_row_major_and_shrink_V_SSS(uint8_t** v, unsigned int ell) {
  // V is \hat \ell times \lambda matrix over F_2
  // v has \hat \ell rows, \lambda columns, storing in column-major order, new_v has \ell + 2
  // \lambda rows and \lambda columns storing in row-major order
  bfSSS_t* new_v = BFSSS_ALLOC(ell + RESOLVED_SSS_LAMBDA * 2);
  assert(new_v);
  for (unsigned int row = 0; row != ell + RESOLVED_SSS_LAMBDA * 2; ++row) {
    uint8_t new_row[BFSSS_NUM_BYTES] = {0};
    for (unsigned int column = 0; column != RESOLVED_SSS_LAMBDA; ++column) {
      ptr_set_bit(new_row, column, ptr_get_bit(v[column], row));
    }
    new_v[row] = bfSSS_load(new_row);
  }
  return new_v;
}

typedef struct bs12_constraint_monomial {
  uint32_t length;
  uint32_t coeff[3];
} bs12_constraint_monomial_t;

typedef struct bs12_constraint_poly {
  uint32_t length;
  bs12_constraint_monomial_t monomial[12];
} bs12_constraint_poly_t;

void rsd_compute_bs12_poly_index(const uint32_t witness_index, bs12_constraint_poly_t* poly,
                                 const resolved_paramset_t* params) {
  uint16_t m  = params->code_length;
  uint16_t k  = params->code_dimension;
  uint16_t bs = params->code_block_size;
  // this function only generate constraint poly for bs = 12
  assert(bs == 12);
  assert(witness_index < m);
  // index
  int block_index      = witness_index / 12;
  int block_offset     = block_index % 12;
  int sub_block_index  = block_offset / 4;
  int sub_block_offset = block_offset % 4;
  int a0               = block_index * 4;
  int a1               = a0 + 1;
  int b0               = a0 + 2;
  int b1               = a0 + 3;
  // initialize the results
  memset(poly, 0, sizeof(bs12_constraint_poly_t));
  bs12_constraint_monomial_t sub_block_selector[4];
  memset(sub_block_selector, 0, sizeof(sub_block_selector));
  uint32_t sub_block_selector_length = 0;
  bs12_constraint_monomial_t sub_block_content[3];
  memset(sub_block_content, 0, sizeof(sub_block_content));
  uint32_t sub_block_content_length = 0;
  // switch
  switch (sub_block_index) {
  case 0: // 1st sub-block
    // sub_block_selector has 4 element
    // (a0 + 1) * (a1 + 1) = a0 * a1 + a0 + a1 + 1
    sub_block_selector_length = 4;
    // a0 * a1
    sub_block_selector[0].length   = 2;
    sub_block_selector[0].coeff[0] = a0;
    sub_block_selector[0].coeff[1] = a1;
    // a0
    sub_block_selector[1].length = 1;
    sub_block_selector[1].coeff[0]  = a0;
    // a1
    sub_block_selector[2].length = 1;
    sub_block_selector[2].coeff[0]  = a1;
    // 1
    sub_block_selector[3].length = 0;
    break;

  case 1: // 2nd sub-block
    // sub_block_selector has 2 element
    // (a0) * (a1 + 1) = a0 * a1 + a0
    sub_block_selector_length = 2;
    // a0 * a1
    sub_block_selector[0].length   = 2;
    sub_block_selector[0].coeff[0] = a0;
    sub_block_selector[0].coeff[1] = a1;
    // a0
    sub_block_selector[1].length = 1;
    sub_block_selector[1].coeff[0]  = a0;
    break;

  case 2: // 3rd sub-block
    // sub_block_selector has 2 element
    // (a0 + 1) * (a1) = a0 * a1 + a1
    sub_block_selector_length = 2;
    // a0 * a1
    sub_block_selector[0].length   = 2;
    sub_block_selector[0].coeff[0] = a0;
    sub_block_selector[0].coeff[1] = a1;
    // a0
    sub_block_selector[1].length = 1;
    sub_block_selector[1].coeff[0]  = a1;
    break;

  case 3: // 4th sub-block
    // sub_block_selector has 1 element
    // (a0) * (a1) = a0 * a1
    sub_block_selector_length = 1;
    // a0 * a1
    sub_block_selector[0].length   = 2;
    sub_block_selector[0].coeff[0] = a0;
    sub_block_selector[0].coeff[1] = a1;
    break;
  }

  // now we need to fill the poly with the sub_block_selector
  switch (sub_block_offset) {
  case 0: // b0
    sub_block_content_length      = 1;
    sub_block_content[0].length   = 1;  // b0
    sub_block_content[0].coeff[0] = b0; // b0
    break;

  case 1: // b1
    sub_block_content_length      = 1;
    sub_block_content[0].length   = 1;
    sub_block_content[0].coeff[0] = b1;
    break;

  case 2: // b0 + b1 + 1
    sub_block_content_length      = 3;
    sub_block_content[0].length   = 1;
    sub_block_content[0].coeff[0] = b0;
    sub_block_content[1].length   = 1;
    sub_block_content[1].coeff[0] = b1;
    sub_block_content[2].length   = 0; // constant term 1
    break;
  }

  // polynomial multiplication
  poly->length = sub_block_content_length * sub_block_selector_length; // length of the poly
  for (uint32_t i = 0; i < sub_block_selector_length; i++) {
    for (uint32_t j = 0; j < sub_block_content_length; j++) {
      uint32_t monomial_index = i * sub_block_content_length + j;
      poly->monomial[monomial_index].length =
          sub_block_selector[i].length + sub_block_content[j].length;
      // multiply the monomials
      for (uint32_t ii = 0; ii < sub_block_selector[i].length; ii++) {
        poly->monomial[monomial_index].coeff[ii] = sub_block_selector[i].coeff[ii];
      }
      for (uint32_t ii = 0; ii < sub_block_content[j].length; ii++) {
        poly->monomial[monomial_index].coeff[sub_block_selector[i].length + ii] =
            sub_block_content[j].coeff[ii];
      }
    }
  }
}

// RSD OWF CONSTRAINTS
static void rsd_SSS_constraints_prover(zk_hash_SSS_3_ctx* hasher, const uint8_t* w,
                                       const bfSSS_t* w_tag, const uint8_t* owf_in,
                                       const uint8_t* owf_out, const resolved_paramset_t* params) {

  uint16_t m      = params->code_length;
  uint16_t k      = params->code_dimension;
  uint16_t bs     = params->code_block_size;
  uint16_t lambda = params->lambda;

  uint8_t* H = generate_H_mat(m - k, m, owf_in, lambda);
  for (uint32_t row_index = 0; row_index < m - k; row_index++) {
    // printf("Processing row %u of %u...\n", row_index, m - k);
    bs12_constraint_poly_t poly;
    bfSSS_t tilde_a0 = bfSSS_zero();
    bfSSS_t tilde_a1 = bfSSS_zero();
    bfSSS_t tilde_a2 = bfSSS_zero();
    for (uint32_t col_index = 0; col_index < m; col_index++) {
      if (getH(row_index, col_index, m - k, m, H) == 0) {
        continue;
      }
      rsd_compute_bs12_poly_index(col_index, &poly, params);
      for (uint32_t monomial_index = 0; monomial_index < poly.length; monomial_index++) {
        bs12_constraint_monomial_t* monomial = &poly.monomial[monomial_index];
        if (monomial->length == 0) {
          // constant term
          // prover does not have to deal with this case
          continue;
        } else if (monomial->length == 1) {
          uint32_t a_index = monomial->coeff[0];
          tilde_a2         = bfSSS_add(tilde_a2, w_tag[a_index]);
        } else if (monomial->length == 2) {
          uint32_t a_index = monomial->coeff[0];
          uint32_t b_index = monomial->coeff[1];
          uint8_t a_bit    = ptr_get_bit(w, a_index);
          uint8_t b_bit    = ptr_get_bit(w, b_index);
          bfSSS_t a_tag    = w_tag[a_index];
          bfSSS_t b_tag    = w_tag[b_index];
          tilde_a2         = bfSSS_add(tilde_a2, bfSSS_mul_bit(a_tag, b_bit)); // M[a] * b
          tilde_a2         = bfSSS_add(tilde_a2, bfSSS_mul_bit(b_tag, a_bit)); // M[b] * a
          tilde_a1         = bfSSS_add(tilde_a1, bfSSS_mul(a_tag, b_tag));     // M[a] * M[b]
        } else if (monomial->length == 3) {
          uint32_t a_index = monomial->coeff[0];
          uint32_t b_index = monomial->coeff[1];
          uint32_t c_index = monomial->coeff[2];
          uint8_t a_bit    = ptr_get_bit(w, a_index);
          uint8_t b_bit    = ptr_get_bit(w, b_index);
          uint8_t c_bit    = ptr_get_bit(w, c_index);
          bfSSS_t a_tag    = w_tag[a_index];
          bfSSS_t b_tag    = w_tag[b_index];
          bfSSS_t c_tag    = w_tag[c_index];
          tilde_a2 = bfSSS_add(tilde_a2, bfSSS_mul_bit(a_tag, b_bit * c_bit)); // M[a] * b * c
          tilde_a2 = bfSSS_add(tilde_a2, bfSSS_mul_bit(b_tag, c_bit * a_bit)); // M[b] * c * a
          tilde_a2 = bfSSS_add(tilde_a2, bfSSS_mul_bit(c_tag, a_bit * b_bit)); // M[c] * a * b
          tilde_a1 =
              bfSSS_add(tilde_a1, bfSSS_mul_bit(bfSSS_mul(a_tag, b_tag), c_bit)); // M[a] * M[b] * c
          tilde_a1 =
              bfSSS_add(tilde_a1, bfSSS_mul_bit(bfSSS_mul(b_tag, c_tag), a_bit)); // M[b] * M[c] * a
          tilde_a1 =
              bfSSS_add(tilde_a1, bfSSS_mul_bit(bfSSS_mul(c_tag, a_tag), b_bit)); // M[c] * M[a] * b
          tilde_a0 = bfSSS_add(
              tilde_a0, bfSSS_mul(a_tag, bfSSS_mul(b_tag, c_tag))); // M[a] * M[b] * M[c]
        }
      }
    }

    // Now we have tilde_a0, tilde_a1, tilde_a2 for this row
    zk_hash_SSS_3_update(hasher, tilde_a0, tilde_a1, tilde_a2);
    break;
  }
}

static void rsd_SSS_constraints_verifier(zk_hash_SSS_ctx* hasher, const bfSSS_t* q_key,
                                         const uint8_t* owf_in, const uint8_t* owf_out,
                                         bfSSS_t delta, const resolved_paramset_t* params) {

  uint16_t m      = params->code_length;
  uint16_t k      = params->code_dimension;
  uint16_t bs     = params->code_block_size;
  uint16_t lambda = params->lambda;

  uint8_t* H = generate_H_mat(m - k, m, owf_in, lambda);

  bfSSS_t delta_sq   = bfSSS_mul(delta, delta);
  bfSSS_t delta_cube = bfSSS_mul(delta_sq, delta);

  for (uint32_t row_index = 0; row_index < m - k; row_index++) {
    bs12_constraint_poly_t poly;
    bfSSS_t tilde_q = bfSSS_zero();
    if (ptr_get_bit(owf_out, row_index) == 1) {
      tilde_q = bfSSS_add(tilde_q, delta_cube);
    }

    for (uint32_t col_index = 0; col_index < m; col_index++) {
      if (getH(row_index, col_index, m - k, m, H) == 0) {
        continue;
      }
      rsd_compute_bs12_poly_index(col_index, &poly, params);
      for (uint32_t monomial_index = 0; monomial_index < poly.length; monomial_index++) {
        bs12_constraint_monomial_t* monomial = &poly.monomial[monomial_index];
        if (monomial->length == 0) {
          // constant term
          // add delta^3 to tilde_q
          tilde_q = bfSSS_add(tilde_q, delta_cube);
        } else if (monomial->length == 1) {
          // deg-1 monomial
          // tilde_q += K[a] * delta^2
          uint32_t a_index = monomial->coeff[0];
          tilde_q          = bfSSS_add(tilde_q, bfSSS_mul(q_key[a_index], delta_sq));
        } else if (monomial->length == 2) {
          // deg-2 monomial
          // tilde_q += K[a] * K[b] * delta
          uint32_t a_index = monomial->coeff[0];
          uint32_t b_index = monomial->coeff[1];
          tilde_q = bfSSS_add(tilde_q, bfSSS_mul(bfSSS_mul(q_key[a_index], q_key[b_index]), delta));
        } else if (monomial->length == 3) {
          // deg-3 monomial
          // tilde_q + K[a] * k[b] * K[c]
          uint32_t a_index = monomial->coeff[0];
          uint32_t b_index = monomial->coeff[1];
          uint32_t c_index = monomial->coeff[2];
          tilde_q          = bfSSS_add(tilde_q,
                                       bfSSS_mul(bfSSS_mul(q_key[a_index], q_key[b_index]), q_key[c_index]));
        }
      }
    }

    // Now we have tilde_q for this row
    zk_hash_SSS_update(hasher, tilde_q);
    break;
  }
}

// OWF PROVER
// clang-format off
void rsd_@SSS@_prover(uint8_t* a0_tilde, uint8_t* a1_tilde, uint8_t* a2_tilde, const uint8_t* w,
                    const uint8_t* u, uint8_t** V, const uint8_t* owf_in, const uint8_t* owf_out,
                    const uint8_t* chall_2, const resolved_paramset_t* params) {
  // clang-format on
  const unsigned int ell = params->l;

  // ::1-5
  // V becomes the w_tag: ell + 2*lambda field elements
  bfSSS_t* w_tag = rsd_column_to_row_major_and_shrink_V_SSS(V, ell); // This is the tag for w

  // ::6-7 embed VOLE masks
  bfSSS_t bf_u_star_0 = bfSSS_sum_poly_bits(u);
  bfSSS_t bf_u_star_1 = bfSSS_sum_poly_bits(u + RESOLVED_SSS_LAMBDA / 8);

  // ::8-9
  bfSSS_t bf_v_star_0 = bfSSS_sum_poly(w_tag + ell);
  bfSSS_t bf_v_star_1 = bfSSS_sum_poly(w_tag + ell + RESOLVED_SSS_LAMBDA);

  // Step: 13-18
  zk_hash_SSS_3_ctx hasher;
  zk_hash_SSS_3_init(&hasher, chall_2);

  printf("rsd_SSS_constraints_prover starting...\n");

  rsd_SSS_constraints_prover(&hasher, w, w_tag, owf_in, owf_out, params);

  zk_hash_SSS_3_finalize(a0_tilde, a1_tilde, a2_tilde, &hasher, bf_v_star_0,
                         bfSSS_add(bf_u_star_0, bf_v_star_1), bf_u_star_1);

  faest_aligned_free(w_tag);
}

// OWF VERIFIER
// clang-format off
void rsd_@SSS@_verifier(uint8_t* a0_tilde, const uint8_t* d, uint8_t** Q, const uint8_t* owf_in,
                      const uint8_t* owf_out, const uint8_t* chall_2, const uint8_t* chall_3,
                      const uint8_t* a1_tilde, const uint8_t* a2_tilde,
                      const resolved_paramset_t* params) {
  // clang-format on
  const unsigned int ell = params->l;

  // ::1
  bfSSS_t bf_delta    = bfSSS_load(chall_3);
  bfSSS_t bf_delta_sq = bfSSS_mul(bf_delta, bf_delta);

  // ::2-6
  bfSSS_t* q_key = rsd_column_to_row_major_and_shrink_V_SSS(Q, ell);

  // ::7-9
  bfSSS_t q_star_0 = bfSSS_sum_poly(q_key + ell);
  bfSSS_t q_star_1 = bfSSS_sum_poly(q_key + ell + RESOLVED_SSS_LAMBDA);

  // ::10
  bfSSS_t q_star = bfSSS_add(q_star_0, bfSSS_mul(bf_delta, q_star_1));

  // ::13-14
  zk_hash_SSS_ctx b_ctx;
  zk_hash_SSS_init(&b_ctx, chall_2);

  for (unsigned int i = 0; i < ell; i++) {
    q_key[i] = bfSSS_add(q_key[i], bfSSS_mul_bit(bf_delta, ptr_get_bit(d, i)));
  }

  // ::11-12
  rsd_SSS_constraints_verifier(&b_ctx, q_key, owf_in, owf_out, bf_delta, params);
  faest_aligned_free(q_key);

  // ::13-14
  uint8_t q_tilde[RESOLVED_SSS_LAMBDA / 8];
  zk_hash_SSS_finalize(q_tilde, &b_ctx, q_star);

  // ::16
  bfSSS_t tmp1 = bfSSS_mul(bfSSS_load(a1_tilde), bf_delta);
  bfSSS_t tmp2 = bfSSS_mul(bfSSS_load(a2_tilde), bf_delta_sq);
  bfSSS_t tmp3 = bfSSS_add(tmp1, tmp2);
  bfSSS_t ret  = bfSSS_add(bfSSS_load(q_tilde), tmp3);

  bfSSS_store(a0_tilde, ret);
}
