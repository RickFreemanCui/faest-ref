/*
 *  SPDX-License-Identifier: MIT
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "resolved_@PARAM_L@.h"
#include "aes.h"
#include "compat.h"
#include "faest_impl.h"
#include "instances.h"
#include "owf.h"
#include "parameters.h"
#include "randomness.h"
#include "utils.h"
#include "random_oracle.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// memory layout of the public key: OWF input || OWF output
#define PK_INPUT(pk) (pk)
#define PK_OUTPUT(pk) (&pk[@OWF_INPUT_SIZE@])

// memory layout of the secret key: OWF input || OWF key
#define SK_INPUT(sk) (sk)
#define SK_KEY(sk) (&sk[@OWF_INPUT_SIZE@])

static_assert(@PK_SIZE@ == @OWF_INPUT_SIZE@ + @OWF_OUTPUT_SIZE@, "invalid public key size");
static_assert(@SK_SIZE@ == @OWF_INPUT_SIZE@ + @LAMBDA@ / 8, "invalid secret key size");

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_keygen(uint8_t* pk, uint8_t* sk) {
  if (!pk || !sk) {
    return -1;
  }
  rand_bytes(sk, @SK_SIZE@);
  // declassify OWF input
  // faest_declassify(SK_INPUT(sk), @OWF_INPUT_SIZE@);
  resolved_@PARAM_L@_owf(SK_KEY(sk), SK_INPUT(sk), PK_OUTPUT(pk));
  memcpy(PK_INPUT(pk), SK_INPUT(sk), @OWF_INPUT_SIZE@);
  // declassify public key
  // faest_declassify(pk, @PK_SIZE@);
  return 0;
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_unpack_private_key(resolved_@PARAM_L@_unpacked_private_key_t* unpacked_sk, const uint8_t* sk) {
  if (!unpacked_sk || !sk) {
    return -1;
  }

  memcpy(unpacked_sk->owf_input, SK_INPUT(sk), sizeof(unpacked_sk->owf_input));
  memcpy(unpacked_sk->owf_key, SK_KEY(sk), sizeof(unpacked_sk->owf_key));
  // compute the witness
  uint8_t *e = (uint8_t *)malloc(@M@);
  generate_e(e, @M@, @W@, @BLOCK_SIZE@, SK_KEY(sk), @LAMBDA@);
  uint8_t *w = (uint8_t *)malloc(@ELL@);
  for (int sub_block_index = 0; sub_block_index < @W@; sub_block_index++) {
    int start_index = sub_block_index * @BLOCK_SIZE@;
    // determine which sub-block is valid and record the valid sub-block
    int a1 = -1;
    int a0 = -1;
    int b1 = -1;
    int b0 = -1;

    int valid_offset = 0;
    while (e[start_index + valid_offset] != 1) {
      valid_offset++;
    }
    a1 = (valid_offset / 3) / 2;
    a0 = (valid_offset / 3) % 2;
    b1 = e[start_index + (a1 * 2 + a0) * 3 + 1];
    b0 = e[start_index + (a1 * 2 + a0) * 3];

    w[sub_block_index * 4] = a0;
    w[sub_block_index * 4 + 1] = a1;
    w[sub_block_index * 4 + 2] = b0;
    w[sub_block_index * 4 + 3] = b1;
  }

  // pack the w vector
  memset(unpacked_sk->witness, 0, sizeof (unpacked_sk->witness));
  for (int i = 0; i < @ELL@; i++) {
    ptr_set_bit(unpacked_sk->witness, i, w[i]);
  }
  free(e);
  free(w);

  resolved_@PARAM_L@_owf(SK_KEY(sk), SK_INPUT(sk), unpacked_sk->owf_output);

  // declassify OWF output
  // faest_declassify(unpacked_sk->owf_output, sizeof(unpacked_sk->owf_output));

  const resolved_paramset_t* params = resolved_get_paramset(RESOLVED_@PARAM@);

  return 0;
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_validate_keypair(const uint8_t* pk, const uint8_t* sk) {
  if (!sk || !pk) {
    return -1;
  }

  uint8_t pk_check[@PK_SIZE@];
  resolved_@PARAM_L@_owf(SK_KEY(sk), SK_INPUT(sk), PK_OUTPUT(pk_check));
  memcpy(PK_INPUT(pk_check), SK_INPUT(sk), @OWF_INPUT_SIZE@);

  return faest_timingsafe_bcmp(pk_check, pk, sizeof(pk_check)) == 0 ? 0 : 2;
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_sign_with_randomness(const uint8_t* sk, const uint8_t* message, size_t message_len, const uint8_t* rho, size_t rho_len, uint8_t* signature, size_t* signature_len) {
  if (!sk || !signature || !signature_len || *signature_len < RESOLVED_@PARAM@_SIGNATURE_SIZE || (!rho && rho_len)) {
    return -1;
  }

  resolved_@PARAM_L@_unpacked_private_key_t unpacked_sk;
  int ret = resolved_@PARAM_L@_unpack_private_key(&unpacked_sk, sk);
  if (ret) {
    resolved_@PARAM_L@_clear_unpacked_private_key(&unpacked_sk);
    return ret;
  }


  ret = resolved_@PARAM_L@_unpacked_sign_with_randomness(&unpacked_sk, message, message_len, rho, rho_len, signature, signature_len);
  

  resolved_@PARAM_L@_clear_unpacked_private_key(&unpacked_sk);
  return ret;
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_sign(const uint8_t* sk, const uint8_t* message, size_t message_len, uint8_t* signature, size_t* signature_len) {
  if (!sk || !signature || !signature_len || *signature_len < RESOLVED_@PARAM@_SIGNATURE_SIZE) {
    return -1;
  }

  uint8_t rho[RESOLVED_@PARAM@_LAMBDA / 8] = {0};
  // rand_bytes(rho, sizeof(rho));

  return resolved_@PARAM_L@_sign_with_randomness(sk, message, message_len, rho, sizeof(rho), signature, signature_len);
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_unpacked_sign(const resolved_@PARAM_L@_unpacked_private_key_t* sk, const uint8_t* message, size_t message_len, uint8_t* signature, size_t* signature_len) {
  if (!sk || !signature || !signature_len || *signature_len < RESOLVED_@PARAM@_SIGNATURE_SIZE) {
    return -1;
  }

  uint8_t rho[RESOLVED_@PARAM@_LAMBDA / 8] = {0};
  // rand_bytes(rho, sizeof(rho));

  return resolved_@PARAM_L@_unpacked_sign_with_randomness(sk, message, message_len, rho, sizeof(rho), signature, signature_len);
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_unpacked_sign_with_randomness(const resolved_@PARAM_L@_unpacked_private_key_t* sk, const uint8_t* message, size_t message_len, const uint8_t* rho, size_t rho_len, uint8_t* signature, size_t* signature_len) {
  if (!sk || !signature || !signature_len || *signature_len < RESOLVED_@PARAM@_SIGNATURE_SIZE) {
    return -1;
  }

  const resolved_paramset_t* params = resolved_get_paramset(RESOLVED_@PARAM@);
  resolved_sign(signature, message, message_len, sk->owf_key, sk->owf_input, sk->owf_output, sk->witness, rho, rho_len, params);
  *signature_len = RESOLVED_@PARAM@_SIGNATURE_SIZE;

  return 0;
}

int FAEST_CALLING_CONVENTION resolved_@PARAM_L@_verify(const uint8_t* pk, const uint8_t* message, size_t message_len, const uint8_t* signature, size_t signature_len) {
  if (!pk || !signature || signature_len != RESOLVED_@PARAM@_SIGNATURE_SIZE) {
    return -1;
  }

  const resolved_paramset_t* params = resolved_get_paramset(RESOLVED_@PARAM@);

  return resolved_verify(message, message_len, signature, PK_INPUT(pk), PK_OUTPUT(pk), params);
}

void FAEST_CALLING_CONVENTION resolved_@PARAM_L@_clear_private_key(uint8_t* key) {
  faest_explicit_bzero(key, RESOLVED_@PARAM@_PRIVATE_KEY_SIZE);
}

void FAEST_CALLING_CONVENTION resolved_@PARAM_L@_clear_unpacked_private_key(resolved_@PARAM_L@_unpacked_private_key_t* key) {
  faest_explicit_bzero(key, sizeof(*key));
}

// vim: ft=c
